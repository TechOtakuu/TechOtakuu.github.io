[{"path":"/2024/04/29/算法学习-Day1/","content":"算法学习Day-1一.双指针介绍双指针又称尺取法，是一种常用的优化技巧，常用来解决序列的区间问题 当问题跟序列的区间有关，且需要两个操作变量，可以使用两个下标（指针）i 和 j 扫描区间。 通常：使用 i 和 j 分别扫描区间，有二重循环，复杂度为O(n^2) 12345for(int i=0;i&lt;n;i++)&#123; for(int j=n-1;j&gt;=0;j--)&#123; ... &#125;&#125; 下面使用双指针优化。 将二重循环变为一个循环，在这个循环中同时处理 i 和 j 。复杂度变为O(n) 123456int i=0,j=n-1;while(i&lt;j)&#123; ... i++; j--;&#125; 或 123for(int i=0,j=n-1;i&lt;j;i++,j--)&#123; ...&#125; i 和 j 有两种扫描方向： (1)反向扫描：i 和 j 方向相反，一个从头到尾，一个从尾到头，在中间相会。(左右指针) (2)同向扫描：i 和 j 方向相同，都从头到尾，速度不同。可以理解为一个大小可变的滑动窗口。(快慢指针) 反向扫描例题：leetcode125 验证回文串 如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。 字母和数字都属于字母数字字符。 给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。 示例 1： 123输入: s = &quot;A man, a plan, a canal: Panama&quot;输出：true解释：&quot;amanaplanacanalpanama&quot; 是回文串。 分析：首先去除输入字符串的非数字或字母字符后，使用反向扫描，当 i 所指的字符不等于 j 所指的字符时返回false，循环完毕，未返回false时返回true 代码： 1234567891011121314151617181920class Solution &#123;public: bool isPalindrome(string s) &#123; string temp; for(int i=0;i&lt;s.size();i++)&#123; s[i]=tolower(s[i]); cout&lt;&lt;s[i]; if(isdigit(s[i])||isalnum(s[i]))&#123; temp.push_back(s[i]); &#125; &#125; for(int i=0,j=temp.size()-1;i&lt;j;i++,j--)&#123; if(temp[i]!=temp[j])&#123; return false; &#125; &#125; return true; &#125;&#125;; 同向扫描例题:滑动求和 给你一个大小为n的整型数组和一个大小为k的滑动窗口，将滑动窗口从头移到尾，输出从开始到结束每一个时刻滑动窗口内的数的和。 123456789101112131415161718192021222324252627282930313233public class Solution &#123; /** * @param nums: a list of integers. * @param k: length of window. * @return: the sum of the element inside the window at each moving. */ public int[] winSum(int[] nums, int k) &#123; if(nums == null || nums.length == 0)&#123; return new int[]&#123;&#125;; &#125; if(k == 0)&#123; return new int[nums.length]; &#125; int[] results = new int[nums.length - k + 1]; int j = 0, sum = 0; for(int i = 0; i &lt; nums.length; i++)&#123; while(j - i &lt; k &amp;&amp; j &lt; nums.length)&#123; sum += nums[j]; j ++; &#125; if(j - i == k)&#123; results[i] = sum; &#125; sum -= nums[i]; &#125; return results; &#125;&#125;"}]